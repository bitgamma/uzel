var mrf24j40 = require('node-mrf24j40');
var MRF24J40 = mrf24j40.MRF24J40;
var ControlRegister = mrf24j40.ControlRegister;
var FIFO = mrf24j40.FIFO;

var osnp = require('node-osnp');
var FrameType = osnp.FrameType;
var FrameVersion = osnp.FrameVersion;
var AddressingMode = osnp.AddressingMode;

var radio;
var frameQueue = [];
var cbCache = {};
var transmissionPending = false;

exports.start = function() {
  if (process.platform == 'linux') {
    radio = new MRF24J40('raspi');    
  }

  osnp.setPANID(new Buffer([0xfe, 0xca]));
  osnp.setShortAddress(new Buffer([0xbe, 0xba]));      
  
  if (radio) {
    radio.on('frame', handleReceived);
    radio.on('transmitted', handleTransmitted);
    radio.initialize(11);
    radio.setPANCoordinator();
    radio.setPANID(osnp.getPANID());
    radio.setShortAddress(osnp.getShortAddress());      
  }
}

exports.pair = function(device, pairingData, cb) {
  //TODO: here assign short address from eui
  cb(device);
}

exports.unpair = function(device, cb) {
  //TODO: remove association here
  cb(device);
}

exports.discoverDevices = function(cb) {
  //substitute with real code
  var discoveredDevices = [];
  
  if (radio) {
    discoveredDevices = [ new OSNPProtocolInfo(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), new Buffer([0xef, 0xbe]))];
  }

  for(var i = 0, len = discoveredDevices.length; i < len; i++) {
    var dev = discoveredDevices[i];
    cb(dev.toID(), dev);
  }
}

exports.send = function(device, data, cb) {  
  var frameControlLow = osnp.makeFrameControlLow(FrameType.DATA, false, false, true, true);
  var frameControlHigh = osnp.makeFrameControlHigh(AddressingMode.SHORT_ADDRESS, FrameVersion.V2003, AddressingMode.SHORT_ADDRESS);
  
  var frame = osnp.createFrame(frameControlLow, frameControlHigh);
  frame.destinationAddress = device.protocolInfo.shortAddress;
  frame.payload = data;
  
  frameQueue.push(frame);
  cbCache[device.protocolInfo.shortAddress.toString('hex')] = cb;
  trySend();
}

function trySend() {
  if (!transmissionPending && (frameQueue.length > 0)) {
    var frame = frameQueue.shift();
    transmissionPending = frame;
    var frameLength = frame.getEncodedLength();
    var buf = new Buffer(frameLength + 2);
    buf[0] = frameLength - frame.payload.length;
    buf[1] = frameLength;
    frame.encode(buf.slice(2));
    radio.transmit(buf);
  }
}

function handleReceived(rawFrame, lqi, rssi) {
  var frame = osnp.parseFrame(rawFrame);
  var cb = cbCache[frame.sourceAddress.toString('hex')];
  
  //TODO: what to do with data generated by the device (notification)
  if (cb) {
    delete cbCache[frame.sourceAddress.toString('hex')];
    cb(frame.payload);
  }
}

function handleTransmitted(txErr, ccaErr) {
  if(ccaErr) {
    frameQueue.push(transmissionPending);
  } else if (txErr) {
    delete cbCache[transmissionPending.destinationAddress.toString('hex')];    
  }
  
  transmissionPending = null;
  trySend();
}

function OSNPProtocolInfo(eui, shortAddress) {
  this.eui = eui;
  this.shortAddress = shortAddress;
}

OSNPProtocolInfo.prototype.toID = function() {
  return this.eui.toString('hex');
}

